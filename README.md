# LEX-simulation

A C/C++ program that works like the LEX tool.

Given k regular expressions r1, r2, . . . , rk (in the same order) and a string w, the tool breaks the input w into a sequence of longest lexemes that can be generated by a regular expression from r1, . . . , rk. It will be echoed if any regular expression cannot generate a character in w.

Code takes k regular expressions r1,r2,...,rk, and a string w as an input and outputs the sequences of longest lexemes along with the index of the regular expression that can generate the lexeme.


## Input Format:

The input is read from a text file, named input.txt and the file contains the input string w in the first line and contains a sequence of regular expressions r1 , r2 , . . . , rk , one per line. Note that k is not part of the input.
Please note that each sub-regular expression is parenthesized.

## Output Format

Output.txt contains one string that represents the output and string is of the form < lexeme1, t1 >< lexeme2, t2 > · · · < lexemen, tn > (do not use any extra spaces) where lexeme1 is the longest prefix of the input w that can be generated by regular expression rt1 , and lexeme2 is the longest prefix of the remaining input w that can be generated by regular expression rt2 , and so on.
- If lexemei can be generated by more than one regular expression from {r1, r2, . . . , rk}, then ti is the lowest index among the regular expressions that can generate lexemei.
- If lexemei is not generated by any regular expression (i.e., lexemei is echoed), then ti is 0.

